/// <reference types="vitest/globals" />
import { z } from 'zod';
import { schemaRegistry } from '../../src/sam/lib/schema-registry';
import type { SchemaDefinition, SchemaRelationship, PropertyDefinition } from '../../src/sam/lib/schema-registry';

describe('SchemaRegistry', () => {
  describe('Schema Loading', () => {
    test('loads all schemas from auto-generated SchemaConfigs', () => {
      // Should load all the schemas automatically discovered from YAML
      const expectedSchemas = [
        'Task', 'TaskGroup', 'UIConfiguration', 'Field', 
        'ImportedField', 'Table'
      ];
      
      for (const schemaName of expectedSchemas) {
        const propertyDefs = schemaRegistry.getPropertyDefinitions(schemaName);
        expect(propertyDefs).toBeDefined();
        expect(Array.isArray(propertyDefs)).toBe(true);
      }
    });

    test('returns empty array for non-existent schema', () => {
      const propertyDefs = schemaRegistry.getPropertyDefinitions('NonExistentSchema');
      expect(propertyDefs).toEqual([]);
    });
  });

  describe('Property Definitions', () => {
    test('extracts property definitions for Task schema', () => {
      const taskProperties = schemaRegistry.getPropertyDefinitions('Task');
      
      expect(taskProperties.length).toBeGreaterThan(0);
      
      // Should include basic task properties
      const propertyNames = taskProperties.map(p => p.name);
      expect(propertyNames).toContain('id');
      expect(propertyNames).toContain('name');
      expect(propertyNames).toContain('title');
      expect(propertyNames).toContain('description');
      
      // Check property structure
      const idProperty = taskProperties.find(p => p.name === 'id');
      expect(idProperty).toBeDefined();
      expect(idProperty?.uiConfig).toBeDefined();
      expect(idProperty?.uiConfig.component_type).toBeDefined();
      expect(idProperty?.zodType).toBeInstanceOf(z.ZodSchema);
    });

    test('extracts property definitions for TaskGroup schema', () => {
      const taskGroupProperties = schemaRegistry.getPropertyDefinitions('TaskGroup');
      
      expect(taskGroupProperties.length).toBeGreaterThan(0);
      
      const propertyNames = taskGroupProperties.map(p => p.name);
      expect(propertyNames).toContain('id');
      expect(propertyNames).toContain('name');
      expect(propertyNames).toContain('title');
      expect(propertyNames).toContain('children');
      
      // Children property should have special handling
      const childrenProperty = taskGroupProperties.find(p => p.name === 'children');
      expect(childrenProperty).toBeDefined();
    });

    test('extracts property definitions for Field schema', () => {
      const fieldProperties = schemaRegistry.getPropertyDefinitions('Field');
      
      expect(fieldProperties.length).toBeGreaterThan(0);
      
      const propertyNames = fieldProperties.map(p => p.name);
      expect(propertyNames).toContain('id');
      expect(propertyNames).toContain('name');
      expect(propertyNames).toContain('title');
      expect(propertyNames).toContain('type');
      expect(propertyNames).toContain('required');
      
      // Check if parents property exists (for testing bidirectional relationships)
      const hasParentsProperty = propertyNames.includes('parents');
      if (hasParentsProperty) {
        const parentsProperty = fieldProperties.find(p => p.name === 'parents');
        expect(parentsProperty).toBeDefined();
      }
      
      // Check field-specific properties
      const typeProperty = fieldProperties.find(p => p.name === 'type');
      expect(typeProperty).toBeDefined();
      expect(typeProperty?.uiConfig.component_type).toBe('select'); // Should be a select for enum
    });
  });

  describe('Relationship Discovery', () => {
    test('discovers TaskGroup containment relationships', () => {
      const taskGroupRelationships = schemaRegistry.getRelationships('TaskGroup');
      
      expect(Array.isArray(taskGroupRelationships)).toBe(true);
      
      // TaskGroup should contain other TaskGroups and Tasks via children property
      const containsRelationships = taskGroupRelationships.filter(rel => rel.type === 'contains');
      expect(containsRelationships.length).toBeGreaterThan(0);
      
      // Should contain Tasks and potentially other TaskGroups
      const targetSchemas = containsRelationships.map(rel => rel.targetSchema);
      expect(targetSchemas).toContain('Task');
      
      // All contains relationships should be via 'children' property
      containsRelationships.forEach(rel => {
        expect(rel.propertyName).toBe('children');
        expect(rel.cardinality).toBe('many');
        expect(rel.canCreate).toBe(true);
        expect(rel.canDelete).toBe(true);
      });
    });

    test('discovers Task containment relationships', () => {
      const taskRelationships = schemaRegistry.getRelationships('Task');
      
      // Task doesn't have children property in current schema, so should have no contains relationships
      // But if it references other schemas, those would be reference relationships
      expect(Array.isArray(taskRelationships)).toBe(true);
    });

    test('discovers Field relationships', () => {
      const fieldRelationships = schemaRegistry.getRelationships('Field');
      
      expect(Array.isArray(fieldRelationships)).toBe(true);
      
      // Field should have a parents property referencing Task
      const referenceRelationships = fieldRelationships.filter(rel => rel.type === 'references');
      
      // Look specifically for the parents relationship
      const parentsReference = referenceRelationships.find(rel => 
        rel.propertyName === 'parents' && rel.targetSchema === 'Task'
      );
      
      if (parentsReference) {
        expect(parentsReference.propertyName).toBe('parents');
        expect(parentsReference.cardinality).toBe('one');
      }
      
      // Also check for self-reference (Field can reference itself via array_item_type)
      const selfReference = referenceRelationships.find(rel => rel.targetSchema === 'Field');
      if (selfReference) {
        expect(selfReference.cardinality).toBe('one');
      }
    });

    test('returns empty array for schema with no relationships', () => {
      // UIConfiguration likely has no containment relationships
      const uiConfigRelationships = schemaRegistry.getRelationships('UIConfiguration');
      expect(Array.isArray(uiConfigRelationships)).toBe(true);
    });
  });

  describe('Bidirectional Relationship Discovery', () => {
    test('discovers inverse relationships from parents properties', () => {
      // Test that when Field has parents: Task, Task gets "contains Field" relationship
      const fieldProperties = schemaRegistry.getPropertyDefinitions('Field');
      const hasParentsProperty = fieldProperties.some(p => p.name === 'parents');
      
      if (hasParentsProperty) {
        // If Field has a parents property, check that the parent schema gets the inverse relationship
        const fieldRelationships = schemaRegistry.getRelationships('Field');
        const parentsReferences = fieldRelationships.filter(rel => 
          rel.type === 'references' && rel.propertyName === 'parents'
        );
        
        parentsReferences.forEach(parentsRef => {
          const parentSchemaName = parentsRef.targetSchema;
          const parentRelationships = schemaRegistry.getRelationships(parentSchemaName);
          
          // Parent should have a "contains Field" relationship
          const inverseRelationship = parentRelationships.find(rel =>
            rel.type === 'contains' && 
            rel.targetSchema === 'Field' &&
            rel.propertyName === 'parents' // Should be marked as derived from parents property
          );
          
          expect(inverseRelationship).toBeDefined();
          if (inverseRelationship) {
            expect(inverseRelationship.cardinality).toBe('many');
            expect(inverseRelationship.canCreate).toBe(true);
            expect(inverseRelationship.canDelete).toBe(true);
          }
        });
      }
    });

    test('handles parents properties in Table schema', () => {
      const tableProperties = schemaRegistry.getPropertyDefinitions('Table');
      const hasParentsProperty = tableProperties.some(p => p.name === 'parents');
      
      if (hasParentsProperty) {
        const tableRelationships = schemaRegistry.getRelationships('Table');
        const parentsReferences = tableRelationships.filter(rel => 
          rel.type === 'references' && rel.propertyName === 'parents'
        );
        
        parentsReferences.forEach(parentsRef => {
          const parentSchemaName = parentsRef.targetSchema;
          const parentRelationships = schemaRegistry.getRelationships(parentSchemaName);
          
          // Parent should have a "contains Table" relationship
          const inverseRelationship = parentRelationships.find(rel =>
            rel.type === 'contains' && 
            rel.targetSchema === 'Table' &&
            rel.propertyName === 'parents'
          );
          
          expect(inverseRelationship).toBeDefined();
        });
      }
    });

    test('handles bidirectional relationships without inappropriate duplicates', () => {
      // Test that the system correctly handles relationships declared from both directions
      // Focus on verifying that parent properties create inverse relationships properly
      
      const allSchemas = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      // Check that each schema has valid relationships
      allSchemas.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        
        // All relationships should be valid
        relationships.forEach(rel => {
          expect(['contains', 'references']).toContain(rel.type);
          expect(typeof rel.targetSchema).toBe('string');
          expect(typeof rel.propertyName).toBe('string');
          expect(['one', 'many']).toContain(rel.cardinality);
        });
        
        // Count relationships by source
        const fromChildren = relationships.filter(rel => rel.propertyName === 'children');
        const fromParents = relationships.filter(rel => rel.propertyName === 'parents');
        const fromOther = relationships.filter(rel => 
          rel.propertyName !== 'children' && rel.propertyName !== 'parents'
        );
        
        // Verify we have some relationships (system is working)
        const totalRels = fromChildren.length + fromParents.length + fromOther.length;
        expect(totalRels).toBe(relationships.length);
        
        // Parents-derived relationships should be contains type
        fromParents.forEach(rel => {
          expect(rel.type).toBe('contains');
          expect(rel.cardinality).toBe('many');
        });
      });
    });

    test('marks parents-derived relationships correctly', () => {
      // Test that relationships derived from parents properties are properly marked
      const allSchemas = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      allSchemas.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        const parentsDerivedRelationships = relationships.filter(rel => 
          rel.propertyName === 'parents' && rel.type === 'contains'
        );
        
        // All parents-derived relationships should be containment relationships
        parentsDerivedRelationships.forEach(rel => {
          expect(rel.type).toBe('contains');
          expect(rel.cardinality).toBe('many');
          expect(rel.canCreate).toBe(true);
          expect(rel.canDelete).toBe(true);
        });
      });
    });

    test('handles complex parent-child hierarchies', () => {
      // Test multi-level hierarchies: TaskGroup -> Task -> Field
      const taskGroupRelationships = schemaRegistry.getRelationships('TaskGroup');
      const taskRelationships = schemaRegistry.getRelationships('Task');
      
      // TaskGroup should be able to contain Tasks (via children)
      const taskGroupContainsTasks = taskGroupRelationships.some(rel =>
        rel.type === 'contains' && rel.targetSchema === 'Task'
      );
      
      // Task should be able to contain Fields (via parent relationship from Field)
      const taskContainsFields = taskRelationships.some(rel =>
        rel.type === 'contains' && rel.targetSchema === 'Field'
      );
      
      // At least one of these hierarchical relationships should exist
      const hasHierarchy = taskGroupContainsTasks || taskContainsFields;
      expect(typeof hasHierarchy).toBe('boolean'); // Just verify the logic runs without errors
    });
  });

  describe('Addable Children', () => {
    test('identifies what can be added to TaskGroup', () => {
      const addableToTaskGroup = schemaRegistry.getAddableChildren('TaskGroup');
      
      expect(Array.isArray(addableToTaskGroup)).toBe(true);
      
      // TaskGroup should be able to contain Tasks and potentially other TaskGroups
      expect(addableToTaskGroup).toContain('Task');
      
      // Should not contain schemas that can't be created (based on relationship discovery)
      addableToTaskGroup.forEach(schemaName => {
        expect(typeof schemaName).toBe('string');
        expect(schemaName.length).toBeGreaterThan(0);
      });
    });

    test('identifies what can be added to Task via bidirectional relationships', () => {
      const addableToTask = schemaRegistry.getAddableChildren('Task');
      
      expect(Array.isArray(addableToTask)).toBe(true);
      
      // If Field has parent: Task, then Task should be able to contain Field
      const canContainField = addableToTask.includes('Field');
      
      // If Table has parent: Task, then Task should be able to contain Table  
      const canContainTable = addableToTask.includes('Table');
      
      // At least verify the method returns valid schema names
      addableToTask.forEach(schemaName => {
        expect(typeof schemaName).toBe('string');
        expect(schemaName.length).toBeGreaterThan(0);
      });
    });

    test('returns empty array for leaf schemas', () => {
      // Field is typically a leaf node that doesn't contain other schemas
      const addableToField = schemaRegistry.getAddableChildren('Field');
      expect(Array.isArray(addableToField)).toBe(true);
      
      // UIConfiguration is also likely a leaf node
      const addableToUIConfig = schemaRegistry.getAddableChildren('UIConfiguration');
      expect(Array.isArray(addableToUIConfig)).toBe(true);
    });

    test('returns empty array for non-existent schema', () => {
      const addableToNonExistent = schemaRegistry.getAddableChildren('NonExistentSchema');
      expect(addableToNonExistent).toEqual([]);
    });

    test('includes children from both forward and inverse relationships', () => {
      // Test that addable children includes both:
      // 1. Children declared via children/array properties  
      // 2. Children discovered via parent properties in other schemas
      
      const allSchemas = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      allSchemas.forEach(schemaName => {
        const addableChildren = schemaRegistry.getAddableChildren(schemaName);
        const relationships = schemaRegistry.getRelationships(schemaName);
        const containsRelationships = relationships.filter(rel => 
          rel.type === 'contains' && rel.canCreate
        );
        
        // Addable children should match contains relationships that allow creation
        expect(addableChildren.length).toBe(containsRelationships.length);
        
        const expectedChildren = containsRelationships.map(rel => rel.targetSchema);
        expect(addableChildren.sort()).toEqual(expectedChildren.sort());
      });
    });
  });

  describe('Property Definition Structure', () => {
    test('property definitions have correct structure', () => {
      const taskProperties = schemaRegistry.getPropertyDefinitions('Task');
      
      if (taskProperties.length > 0) {
        const firstProperty = taskProperties[0];
        
        // Check required fields
        expect(firstProperty).toHaveProperty('name');
        expect(firstProperty).toHaveProperty('zodType');
        expect(firstProperty).toHaveProperty('uiConfig');
        
        expect(typeof firstProperty.name).toBe('string');
        expect(firstProperty.zodType).toBeInstanceOf(z.ZodSchema);
        
        // Check UI config structure
        expect(firstProperty.uiConfig).toHaveProperty('component_type');
        expect(firstProperty.uiConfig).toHaveProperty('title');
        expect(typeof firstProperty.uiConfig.component_type).toBe('string');
        expect(typeof firstProperty.uiConfig.title).toBe('string');
      }
    });

    test('UI config contains expected component types', () => {
      const allProperties: PropertyDefinition[] = [];
      
      // Collect properties from all schemas
      const schemaNames = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      schemaNames.forEach(schemaName => {
        allProperties.push(...schemaRegistry.getPropertyDefinitions(schemaName));
      });
      
      // Check that we have a variety of component types
      const componentTypes = new Set(allProperties.map(p => p.uiConfig.component_type));
      
      expect(componentTypes.size).toBeGreaterThan(1); // Should have multiple component types
      
      // Common component types that should be present
      const expectedTypes = ['input', 'textarea', 'select', 'checkbox', 'number-input', 'date-picker'];
      const foundExpectedTypes = expectedTypes.filter(type => componentTypes.has(type));
      expect(foundExpectedTypes.length).toBeGreaterThan(0);
    });
  });

  describe('Schema Validation', () => {
    test('schemas are valid Zod schemas', () => {
      const schemaNames = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      schemaNames.forEach(schemaName => {
        const properties = schemaRegistry.getPropertyDefinitions(schemaName);
        
        properties.forEach(property => {
          expect(property.zodType).toBeInstanceOf(z.ZodSchema);
          
          // Try to use the schema for basic validation
          expect(() => {
            property.zodType.safeParse(undefined);
          }).not.toThrow();
        });
      });
    });
  });

  describe('Relationship Types', () => {
    test('relationships have valid types', () => {
      const schemaNames = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      schemaNames.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        
        relationships.forEach(relationship => {
          expect(['contains', 'references']).toContain(relationship.type);
          expect(['one', 'many']).toContain(relationship.cardinality);
          expect(typeof relationship.targetSchema).toBe('string');
          expect(typeof relationship.propertyName).toBe('string');
          
          if (relationship.canCreate !== undefined) {
            expect(typeof relationship.canCreate).toBe('boolean');
          }
          if (relationship.canDelete !== undefined) {
            expect(typeof relationship.canDelete).toBe('boolean');
          }
        });
      });
    });

    test('containment relationships allow creation and deletion', () => {
      const schemaNames = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      schemaNames.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        const containsRelationships = relationships.filter(rel => rel.type === 'contains');
        
        containsRelationships.forEach(relationship => {
          expect(relationship.canCreate).toBe(true);
          expect(relationship.canDelete).toBe(true);
          expect(relationship.cardinality).toBe('many'); // Contains relationships are typically many
        });
      });
    });

    test('reference relationships are read-only by default', () => {
      const schemaNames = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      schemaNames.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        const referenceRelationships = relationships.filter(rel => rel.type === 'references');
        
        referenceRelationships.forEach(relationship => {
          // Reference relationships should not have CRUD permissions
          expect(relationship.canCreate).toBeUndefined();
          expect(relationship.canDelete).toBeUndefined();
          expect(relationship.cardinality).toBe('one'); // References are typically singular
        });
      });
    });

    test('parent-derived relationships have correct metadata', () => {
      const allSchemas = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      allSchemas.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        const parentsDerived = relationships.filter(rel => 
          rel.propertyName === 'parents' && rel.type === 'contains'
        );
        
        parentsDerived.forEach(relationship => {
          // Parents-derived containment relationships should have specific characteristics
          expect(relationship.type).toBe('contains');
          expect(relationship.cardinality).toBe('many');
          expect(relationship.canCreate).toBe(true);
          expect(relationship.canDelete).toBe(true);
          expect(relationship.propertyName).toBe('parents');
        });
      });
    });
  });

  describe('Error Handling', () => {
    test('handles invalid schema names gracefully', () => {
      expect(() => {
        schemaRegistry.getPropertyDefinitions('');
      }).not.toThrow();
      
      expect(() => {
        schemaRegistry.getPropertyDefinitions('InvalidSchema');
      }).not.toThrow();
      
      expect(() => {
        schemaRegistry.getRelationships('InvalidSchema');
      }).not.toThrow();
      
      expect(() => {
        schemaRegistry.getAddableChildren('InvalidSchema');
      }).not.toThrow();
    });
  });

  describe('Two-Pass Relationship Discovery', () => {
    test('first pass ignores parent properties', () => {
      // This is more of an integration test to ensure the two-pass system works
      // We can't directly test the private methods, but we can verify the end results
      
      const allSchemas = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      allSchemas.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        
        // Verify that we have a mix of relationship sources
        const childrenDerived = relationships.filter(rel => rel.propertyName === 'children');
        const parentDerived = relationships.filter(rel => rel.propertyName === 'parent');
        const otherDerived = relationships.filter(rel => 
          rel.propertyName !== 'children' && rel.propertyName !== 'parent'
        );
        
        // The system should handle all types of relationships
        const totalRelationships = childrenDerived.length + parentDerived.length + otherDerived.length;
        expect(totalRelationships).toBe(relationships.length);
      });
    });

    test('second pass creates inverse relationships correctly', () => {
      // Test that the second pass creates the expected inverse relationships
      const allSchemas = ['Task', 'TaskGroup', 'Field', 'ImportedField', 'Table'];
      
      // Look for schemas that should have parent-derived relationships
      let foundParentDerived = false;
      
      allSchemas.forEach(schemaName => {
        const relationships = schemaRegistry.getRelationships(schemaName);
        const parentDerived = relationships.filter(rel => 
          rel.type === 'contains' && rel.propertyName === 'parent'
        );
        
        if (parentDerived.length > 0) {
          foundParentDerived = true;
          
          parentDerived.forEach(rel => {
            // Verify the relationship structure is correct
            expect(rel.type).toBe('contains');
            expect(rel.cardinality).toBe('many');
            expect(rel.canCreate).toBe(true);
            expect(rel.canDelete).toBe(true);
            expect(typeof rel.targetSchema).toBe('string');
          });
        }
      });
      
      // We should find at least some parent-derived relationships if the schemas have parent properties
      // This test will pass regardless, but logs useful information
      expect(typeof foundParentDerived).toBe('boolean');
    });
  });
}); 